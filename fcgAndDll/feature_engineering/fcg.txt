完整方案（已更新：包含去重和循环处理）
以下是基于您的路径和 FastText 模型，并明确了如何处理重复和循环的完整 GCN 输入构建方案。
目标：为您在 /mnt/data1_l20_raid5disk/lbq_dataset/dataset/benign_ida_fcg/ 中的每一个 .json 文件，生成一个包含 X（特征矩阵）和 edge_index（关系矩阵）的图数据对象。
预备：加载模型
model = fasttext.load_model("/mnt/data1_l20_raid5disk/lbq_dataset/output/fcg_fasttext/finetuned_fasttext_model.bin")

步骤 1：构建“节点列表”和“索引映射”
此步骤与之前相同，它为每个函数（节点）分配一个唯一的 ID。
加载 JSON 文件（例如 .../**_fcg.json）。
提取唯一节点：使用 fcg_data["call_graph"].keys() 获取最完整的函数名列表。
创建列表和映射：
node_names = list(fcg_data["call_graph"].keys())
name_to_index = {name: i for i, name in enumerate(node_names)}
num_nodes = len(node_names)
步骤 2：构建“特征矩阵” (X)
此步骤与之前相同，它使用 FastText 向量填充特征矩阵。
创建空矩阵：X = np.zeros((num_nodes, 300))
循环填充矩阵：
for i, func_name in enumerate(node_names):
cleaned_name = ... (执行必要的名称清理)
vector = model.get_word_vector(cleaned_name)
X[i] = vector
产出：一个 $N \times 300$ 的特征矩阵 $X$。
步骤 3：构建“关系矩阵” (edge_index) (已更新)
此步骤现在明确包含去重逻辑，并依赖 GCN 层自动处理自循环。
初始化一个 set（用于自动去重）：
edge_set = set()
遍历所有函数调用：
for call in fcg_data["function_calls"]:
caller_name = call["caller"]
callee_name = call["callee"]
查找索引（使用 name_to_index 映射）：
caller_index = name_to_index.get(caller_name)
callee_index = name_to_index.get(callee_name)
检查有效性并添加到 set：
if caller_index is not None and callee_index is not None:
edge_set.add( (caller_index, callee_index) )
(注意：如果 function_calls 中有重复的 (A, B) 调用，set 会自动忽略它们。如果存在递归 (A, A)，set 会保留它。)
转换回列表：
source_nodes = []
target_nodes = []
for src, tgt in edge_set:
source_nodes.append(src)
target_nodes.append(tgt)
格式化为 $2 \times M'$ 矩阵（$M'$ 是唯一边的数量）：
edge_index = torch.tensor([source_nodes, target_nodes], dtype=torch.long)
产出：一个 $2 \times M'$ 的关系矩阵 edge_index（已去重）。
总结
当您将 X 和 edge_index 与标签 y 一起（例如 Data(x=X, edge_index=edge_index, y=y)）送入 GCN 模型时：
重复已被 set 结构在步骤 3 中清除。
自循环（Self-Loops）将由 GCNConv 层在模型前向传播时自动添加。

